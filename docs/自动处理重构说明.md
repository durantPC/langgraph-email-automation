# è‡ªåŠ¨å¤„ç†é‡æ„è¯´æ˜

## é—®é¢˜

ç”¨æˆ·æå‡ºäº†ä¸€ä¸ªéå¸¸å¥½çš„å»ºè®®ï¼š**ä¸ºä»€ä¹ˆä¸æŠŠè‡ªåŠ¨å¤„ç†çš„é€»è¾‘æ”¹æˆå’Œ"å¤„ç†å…¨éƒ¨"æŒ‰é’®ä¸€æ ·ï¼Ÿ**

è¿™ä¸ªå»ºè®®éå¸¸æ­£ç¡®ï¼å› ä¸ºï¼š

1. **"å¤„ç†å…¨éƒ¨"æŒ‰é’®**ï¼šå¼‚æ­¥æ‰§è¡Œ + çº¿ç¨‹æ± å¹¶å‘ + ä¸é˜»å¡
2. **è‡ªåŠ¨å¤„ç†**ï¼ˆå½“å‰ï¼‰ï¼šåŒæ­¥æ‰§è¡Œ + ä¸²è¡Œå¤„ç† + é˜»å¡ç›‘æ§çº¿ç¨‹

## è§£å†³æ–¹æ¡ˆ

### æ ¸å¿ƒæ€è·¯

å°†è‡ªåŠ¨å¤„ç†æ”¹ä¸ºä¸"å¤„ç†å…¨éƒ¨"æŒ‰é’®å®Œå…¨ä¸€è‡´çš„é€»è¾‘ï¼š

1. **å¼‚æ­¥æ‰§è¡Œ**ï¼šä½¿ç”¨ `thread_pool.submit()` åœ¨åå°æ‰§è¡Œï¼Œä¸é˜»å¡ç›‘æ§å¾ªç¯
2. **çº¿ç¨‹æ± å¹¶å‘**ï¼šä½¿ç”¨ `ThreadPoolExecutor` å¹¶å‘å¤„ç†å¤šå°é‚®ä»¶
3. **åˆ†æ‰¹å¤„ç†**ï¼šå°†é‚®ä»¶åˆ†æ‰¹ï¼Œæ¯æ‰¹å¹¶å‘å¤„ç†Nå°ï¼ˆä»ç”¨æˆ·è®¾ç½®ä¸­è·å–ï¼‰

### å®ç°æ­¥éª¤

#### 1. ä¿®æ”¹ç›‘æ§å¾ªç¯

```python
def _monitor_loop(self):
    while self.is_running:
        try:
            # æ£€æŸ¥é‚®ä»¶
            new_emails_count = self._check_emails()
            
            # å¦‚æœå¼€å¯äº†è‡ªåŠ¨å¤„ç†
            if self.auto_process:
                pending_count = len([e for e in self.emails_cache if e.get('status') == 'pending'])
                if pending_count > 0:
                    # åœ¨çº¿ç¨‹æ± ä¸­å¼‚æ­¥æ‰§è¡Œï¼ˆä¸é˜»å¡ç›‘æ§å¾ªç¯ï¼‰
                    print(f"ğŸš€ [è‡ªåŠ¨å¤„ç†] å‘ç° {pending_count} å°å¾…å¤„ç†é‚®ä»¶ï¼Œæäº¤åˆ°çº¿ç¨‹æ± å¼‚æ­¥å¤„ç†")
                    
                    def auto_process_callback(future):
                        """è‡ªåŠ¨å¤„ç†å®Œæˆåçš„å›è°ƒå‡½æ•°"""
                        try:
                            result = future.result()
                            if result:
                                self._notify_frontend({
                                    "type": "auto_process_complete",
                                    "message": result['message'],
                                    "processed": result['processed'],
                                    "skipped": result['skipped'],
                                    "failed": result['failed']
                                })
                        except Exception as e:
                            print(f"âŒ [è‡ªåŠ¨å¤„ç†] å¤„ç†é”™è¯¯: {e}")
                    
                    # æäº¤åˆ°çº¿ç¨‹æ± å¼‚æ­¥æ‰§è¡Œï¼ˆä¸é˜»å¡ç›‘æ§å¾ªç¯ï¼‰
                    future = thread_pool.submit(self._auto_process_emails_async)
                    future.add_done_callback(auto_process_callback)
        
        except Exception as e:
            print(f"ç›‘æ§å¾ªç¯é”™è¯¯: {e}")
        
        time.sleep(self.check_interval)
```

#### 2. é‡å‘½åå‡½æ•°

å°† `_auto_process_emails()` é‡å‘½åä¸º `_auto_process_emails_async()`ï¼Œå¹¶å®Œå…¨å¤åˆ¶"å¤„ç†å…¨éƒ¨"çš„é€»è¾‘ã€‚

#### 3. å…³é”®ä»£ç 

```python
def _auto_process_emails_async(self):
    """è‡ªåŠ¨å¤„ç†æ‰€æœ‰å¾…å¤„ç†é‚®ä»¶ï¼ˆå¼‚æ­¥å¹¶å‘å¤„ç†ï¼Œä¸"å¤„ç†å…¨éƒ¨"æŒ‰é’®é€»è¾‘ä¸€è‡´ï¼‰"""
    from src.nodes import Nodes
    from src.state import Email
    from concurrent.futures import ThreadPoolExecutor, as_completed
    
    # é‡æ–°è·å–ç”¨æˆ·çŠ¶æ€
    task_user_state = get_user_state(self.username)
    pending_emails = [e for e in task_user_state.emails_cache if e.get('status') == 'pending']
    
    if not pending_emails:
        return None
    
    # è·å–ç”¨æˆ·é…ç½®
    user_settings = get_user_settings(self.username)
    batch_size = user_settings.get("batchSize", 4)
    batch_size = max(1, min(30, int(batch_size)))
    
    # ä½¿ç”¨ç‹¬ç«‹çš„æ‰¹é‡å¤„ç†çº¿ç¨‹æ± 
    batch_pool = get_or_create_batch_thread_pool(batch_size)
    
    # å®šä¹‰å¤„ç†å•å°é‚®ä»¶çš„å‡½æ•°
    def process_single_email(email):
        # ... å®Œå…¨å¤åˆ¶"å¤„ç†å…¨éƒ¨"ä¸­çš„ process_single_email é€»è¾‘ ...
        pass
    
    # åˆ†æ‰¹å¹¶å‘å¤„ç†
    total_batches = (len(pending_emails) + batch_size - 1) // batch_size
    
    for batch_idx in range(total_batches):
        start_idx = batch_idx * batch_size
        end_idx = min(start_idx + batch_size, len(pending_emails))
        batch_emails = pending_emails[start_idx:end_idx]
        
        # æäº¤æ‰¹æ¬¡å†…çš„æ‰€æœ‰é‚®ä»¶åˆ°çº¿ç¨‹æ± 
        future_to_email = {
            batch_pool.submit(process_single_email, email): email 
            for email in batch_emails
        }
        
        # ç­‰å¾…æ‰¹æ¬¡å®Œæˆ
        for future in as_completed(future_to_email):
            result = future.result()
            # å¤„ç†ç»“æœ...
    
    # ä¿å­˜æ•°æ®
    with user_lock:
        save_user_email_data(self.username, task_user_state)
    
    return {
        "message": f"è‡ªåŠ¨å¤„ç†å®Œæˆ: {processed_count} å°æˆåŠŸ...",
        "processed": processed_count,
        "skipped": skipped_count,
        "failed": failed_count
    }
```

## ä¼˜åŠ¿å¯¹æ¯”

### ä¿®æ”¹å‰ï¼ˆä¸²è¡Œå¤„ç†ï¼‰

| ç‰¹æ€§ | å½“å‰å®ç° |
|------|---------|
| æ‰§è¡Œæ–¹å¼ | åŒæ­¥ï¼Œé˜»å¡ç›‘æ§çº¿ç¨‹ |
| å¤„ç†æ–¹å¼ | ä¸²è¡Œï¼Œä¸€å°æ¥ä¸€å° |
| å¤„ç†10å°é‚®ä»¶ | 100ç§’ï¼Œç›‘æ§çº¿ç¨‹é˜»å¡100ç§’ |
| ç”¨æˆ·ä½“éªŒ | æ— æ³•åœæ­¢ç›‘æ§ï¼Œæ— æ³•æ‰‹åŠ¨æ“ä½œ |

### ä¿®æ”¹åï¼ˆå¼‚æ­¥å¹¶å‘ï¼‰

| ç‰¹æ€§ | æ–°å®ç° |
|------|--------|
| æ‰§è¡Œæ–¹å¼ | å¼‚æ­¥ï¼Œä¸é˜»å¡ç›‘æ§çº¿ç¨‹ |
| å¤„ç†æ–¹å¼ | å¹¶å‘ï¼Œ4å°åŒæ—¶å¤„ç† |
| å¤„ç†10å°é‚®ä»¶ | çº¦30ç§’ï¼Œç›‘æ§çº¿ç¨‹ä¸é˜»å¡ |
| ç”¨æˆ·ä½“éªŒ | å¯ä»¥éšæ—¶åœæ­¢ç›‘æ§ï¼Œå¯ä»¥æ‰‹åŠ¨æ“ä½œ |

## å®ç°çŠ¶æ€

ç”±äºä»£ç é‡æ„è¿‡ç¨‹ä¸­å‡ºç°äº†ä¸€äº›ç¼©è¿›é”™è¯¯ï¼Œå»ºè®®ï¼š

1. **å¤‡ä»½å½“å‰ä»£ç **
2. **å‚è€ƒ `process_all_emails` å‡½æ•°**ï¼ˆbackend_api.py ç¬¬2904è¡Œï¼‰
3. **å®Œå…¨å¤åˆ¶å…¶é€»è¾‘åˆ° `_auto_process_emails_async`**
4. **ä¿®æ”¹ç›‘æ§å¾ªç¯ï¼Œä½¿ç”¨ `thread_pool.submit()` å¼‚æ­¥è°ƒç”¨**

## å…³é”®ç‚¹

1. **å®Œå…¨å¤åˆ¶"å¤„ç†å…¨éƒ¨"çš„é€»è¾‘**ï¼šä¸è¦é‡æ–°å‘æ˜è½®å­ï¼Œç›´æ¥å¤ç”¨å·²ç»éªŒè¯è¿‡çš„ä»£ç 
2. **å¼‚æ­¥æ‰§è¡Œ**ï¼šä½¿ç”¨ `thread_pool.submit()` è€Œä¸æ˜¯ç›´æ¥è°ƒç”¨å‡½æ•°
3. **å›è°ƒå‡½æ•°**ï¼šä½¿ç”¨ `future.add_done_callback()` å¤„ç†å®Œæˆé€šçŸ¥
4. **WebSocketé€šçŸ¥**ï¼šæ¯å°é‚®ä»¶å¤„ç†å®Œæˆåå‘é€ `email_process_complete` æ¶ˆæ¯

## æ€»ç»“

ç”¨æˆ·çš„å»ºè®®éå¸¸æ­£ç¡®ï¼å°†è‡ªåŠ¨å¤„ç†æ”¹æˆå’Œ"å¤„ç†å…¨éƒ¨"ä¸€æ ·çš„é€»è¾‘ï¼Œå¯ä»¥ï¼š

- âœ… å®Œå…¨ä¸é˜»å¡ç›‘æ§çº¿ç¨‹
- âœ… å¹¶å‘å¤„ç†ï¼Œé€Ÿåº¦æå‡3-5å€
- âœ… ä»£ç å¤ç”¨ï¼Œå‡å°‘ç»´æŠ¤æˆæœ¬
- âœ… ç”¨æˆ·ä½“éªŒæ›´å¥½

è¿™æ˜¯æœ€ä½³çš„è§£å†³æ–¹æ¡ˆï¼
